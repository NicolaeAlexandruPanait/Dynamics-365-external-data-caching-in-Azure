using System;
using System.IO;
using Microsoft.Azure.Functions.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

[assembly: FunctionsStartup(typeof(D365RedisManager.FuncStartup))]

namespace D365RedisManager
{
    class FuncStartup : FunctionsStartup
    {
        public override void Configure(IFunctionsHostBuilder builder)
        {
        }

        public override void ConfigureAppConfiguration(IFunctionsConfigurationBuilder builder)
        {
            FunctionsHostBuilderContext context = builder.GetContext();

            builder.ConfigurationBuilder
                .AddJsonFile(Path.Combine(context.ApplicationRootPath, "appsettings.json"), optional: true, reloadOnChange: false)
                .AddJsonFile(Path.Combine(context.ApplicationRootPath, $"appsettings.{context.EnvironmentName}.json"), optional: true, reloadOnChange: false)
                .AddEnvironmentVariables();
        }
    }
}

using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Microsoft.Extensions.Configuration;
using StackExchange.Redis;
using System.Linq;

namespace D365RedisManager
{
    public class D365RedisManager
    {
        [FunctionName("D365RedisManager")]
        public async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, ILogger log)
        {
            
            string redisConn = _configuration["ConnectionStrings:redisConn"];
            string keyPatternFinder = req.Query["CacheKey"];
            if (string.IsNullOrEmpty(keyPatternFinder))
            {
                return new OkObjectResult($"Invalid CacheKey pattern");
            }
            keyPatternFinder = '*' + keyPatternFinder + '*';

            ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(redisConn);
            IServer redisServer = redis.GetServer(redis.GetEndPoints()[0]);
            IDatabase db = redis.GetDatabase();

            var keys = redisServer.Keys(pattern: keyPatternFinder).ToArray();
            foreach (var key in keys)
            {
                db.KeyDelete(key);
            }
            return new OkObjectResult($"Deleted keys '{string.Join(';',keys)}'");
        }

        private readonly IConfiguration _configuration;

        public D365RedisManager(IConfiguration configuration)
        {
            _configuration = configuration;
        }
    }
}

<policies>
    <inbound>
        <base />
        <cache-lookup vary-by-developer="false" vary-by-developer-groups="false" downstream-caching-type="none" />
        <send-request ignore-error="true" timeout="20" response-variable-name="bearerToken" mode="new">
            <set-url>{{authorizationServer}}</set-url>
            <set-method>POST</set-method>
            <set-header name="Content-Type" exists-action="override">
                <value>application/x-www-form-urlencoded</value>
            </set-header>
            <set-body>@{
                return "client_id={{clientId}}&resource={{scope}}&client_secret={{clientSecret}}&grant_type=client_credentials";
            }</set-body>
        </send-request>
        <set-header name="Authorization" exists-action="override">
            <value>@("Bearer " + (String)((IResponse)context.Variables["bearerToken"]).Body.As<JObject>()["access_token"])</value>
        </set-header>
        <!--  Don't expose APIM subscription key to the backend. -->
        <set-header name="Ocp-Apim-Subscription-Key" exists-action="delete" />
        <set-backend-service base-url="{{scope}}" />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
        <cache-store duration="604800" />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>